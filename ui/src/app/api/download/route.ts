
import { NextRequest, NextResponse } from 'next/server';
import fs from 'fs';
import path from 'path';
import { Readable } from 'stream';

export const runtime = 'nodejs';

export async function GET(request: NextRequest) {
    const searchParams = request.nextUrl.searchParams;
    let fileUrl = searchParams.get('url');
    let filename = searchParams.get('filename') || 'download';

    // Support encoded payload for cleaner URLs
    const dataParam = searchParams.get('data');
    if (dataParam) {
        try {
            const decoded = JSON.parse(atob(dataParam));
            if (decoded.url) fileUrl = decoded.url;
            if (decoded.filename) filename = decoded.filename;
        } catch (e) {
            console.error('Failed to decode download token:', e);
            return new NextResponse('Invalid download token', { status: 400 });
        }
    }

    // Sanitize filename: ensure it's just the basename
    // Handle potential unix or windows paths in the filename param
    filename = filename.split('/').pop() || filename;
    filename = filename.split('\\').pop() || filename;

    if (!fileUrl) {
        return new NextResponse('Missing url parameter', { status: 400 });
    }

    try {
        let responseBody: any = null;
        let responseHeaders = new Headers();
        let status = 200;

        // Handle "mock://" protocol (often found in local/test jobs)
        if (fileUrl.startsWith('mock://')) {
            // "Mock" protocol implies a simulated environment where files might not exist on disk.
            // We generate a placeholder response to allow the download flow to complete.
            const localPath = fileUrl.replace('mock://', '');
            const mockContent = `This is a mock file generated by WebEncode for testing.\nOriginal path: ${localPath}`;

            // If it's supposed to be a video, we could return a small sample or just text.
            // For now, text is safer and clearer that it's a mock.
            const encoder = new TextEncoder();
            const data = encoder.encode(mockContent);

            // Create a stream from the mock data
            const stream = new ReadableStream({
                start(controller) {
                    controller.enqueue(data);
                    controller.close();
                }
            });

            responseBody = stream;
            responseHeaders.set('Content-Length', data.length.toString());
            responseHeaders.set('Content-Type', 'text/plain');

            // If filename implies video, we keep the extension for the download but content is text.
            // This is acceptable for a "mock" filesystem.
        } else {
            // Handle standard HTTP/HTTPS URLs
            const response = await fetch(fileUrl);

            if (!response.ok) {
                console.error(`Failed to fetch file from ${fileUrl}: ${response.status} ${response.statusText}`);
                return new NextResponse(`Failed to fetch file: ${response.statusText}`, { status: response.status });
            }

            responseHeaders = new Headers(response.headers);
            responseBody = response.body;
        }

        // Force download with sanitized filename
        responseHeaders.set('Content-Disposition', `attachment; filename="${filename}"`);

        // Ensure strictly content-type is passed through or defaulted
        if (!responseHeaders.has('Content-Type')) {
            responseHeaders.set('Content-Type', 'application/octet-stream');
        }

        // Stream the response body
        return new NextResponse(responseBody, {
            status: status,
            headers: responseHeaders,
        });
    } catch (error) {
        console.error('Proxy download error:', error);
        return new NextResponse('Internal Server Error', { status: 500 });
    }
}
