// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package store

import (
	"context"
	"net/netip"

	"github.com/jackc/pgx/v5/pgtype"
)

const assignTask = `-- name: AssignTask :exec
UPDATE tasks
SET status = 'assigned', worker_id = $2, updated_at = NOW()
WHERE id = $1
`

type AssignTaskParams struct {
	ID       pgtype.UUID `json:"id"`
	WorkerID pgtype.Text `json:"worker_id"`
}

func (q *Queries) AssignTask(ctx context.Context, arg AssignTaskParams) error {
	_, err := q.db.Exec(ctx, assignTask, arg.ID, arg.WorkerID)
	return err
}

const cancelJob = `-- name: CancelJob :exec
UPDATE jobs
SET status = 'cancelled', finished_at = NOW(), updated_at = NOW()
WHERE id = $1 AND status NOT IN ('completed', 'failed', 'cancelled')
`

func (q *Queries) CancelJob(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, cancelJob, id)
	return err
}

const completeTask = `-- name: CompleteTask :exec
UPDATE tasks
SET status = 'completed', result = $2, output_key = $3, output_size_bytes = $4, updated_at = NOW()
WHERE id = $1
`

type CompleteTaskParams struct {
	ID              pgtype.UUID `json:"id"`
	Result          []byte      `json:"result"`
	OutputKey       pgtype.Text `json:"output_key"`
	OutputSizeBytes pgtype.Int8 `json:"output_size_bytes"`
}

func (q *Queries) CompleteTask(ctx context.Context, arg CompleteTaskParams) error {
	_, err := q.db.Exec(ctx, completeTask,
		arg.ID,
		arg.Result,
		arg.OutputKey,
		arg.OutputSizeBytes,
	)
	return err
}

const countJobs = `-- name: CountJobs :one
SELECT COUNT(*) FROM jobs
`

func (q *Queries) CountJobs(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countJobs)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countJobsByStatus = `-- name: CountJobsByStatus :one
SELECT COUNT(*) FROM jobs WHERE status = $1
`

func (q *Queries) CountJobsByStatus(ctx context.Context, status JobStatus) (int64, error) {
	row := q.db.QueryRow(ctx, countJobsByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPendingTasksForJob = `-- name: CountPendingTasksForJob :one
SELECT COUNT(*) FROM tasks 
WHERE job_id = $1 AND status NOT IN ('completed', 'failed')
`

func (q *Queries) CountPendingTasksForJob(ctx context.Context, jobID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countPendingTasksForJob, jobID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTasksByJobAndStatus = `-- name: CountTasksByJobAndStatus :one
SELECT COUNT(*) FROM tasks WHERE job_id = $1 AND status = $2
`

type CountTasksByJobAndStatusParams struct {
	JobID  pgtype.UUID `json:"job_id"`
	Status string      `json:"status"`
}

func (q *Queries) CountTasksByJobAndStatus(ctx context.Context, arg CountTasksByJobAndStatusParams) (int64, error) {
	row := q.db.QueryRow(ctx, countTasksByJobAndStatus, arg.JobID, arg.Status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAuditLog = `-- name: CreateAuditLog :exec

INSERT INTO audit_log (user_id, action, resource_type, resource_id, details, ip_address, user_agent)
VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type CreateAuditLogParams struct {
	UserID       pgtype.UUID `json:"user_id"`
	Action       string      `json:"action"`
	ResourceType string      `json:"resource_type"`
	ResourceID   pgtype.Text `json:"resource_id"`
	Details      []byte      `json:"details"`
	IpAddress    *netip.Addr `json:"ip_address"`
	UserAgent    pgtype.Text `json:"user_agent"`
}

// ============================================
// AUDIT LOG
// ============================================
func (q *Queries) CreateAuditLog(ctx context.Context, arg CreateAuditLogParams) error {
	_, err := q.db.Exec(ctx, createAuditLog,
		arg.UserID,
		arg.Action,
		arg.ResourceType,
		arg.ResourceID,
		arg.Details,
		arg.IpAddress,
		arg.UserAgent,
	)
	return err
}

const createEncodingProfile = `-- name: CreateEncodingProfile :one
INSERT INTO encoding_profiles (id, name, description, video_codec, audio_codec, width, height, bitrate_kbps, preset, container, config_json)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING id, name, description, video_codec, audio_codec, width, height, bitrate_kbps, preset, container, is_system, config_json, created_at, updated_at
`

type CreateEncodingProfileParams struct {
	ID          string      `json:"id"`
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	VideoCodec  string      `json:"video_codec"`
	AudioCodec  pgtype.Text `json:"audio_codec"`
	Width       pgtype.Int4 `json:"width"`
	Height      pgtype.Int4 `json:"height"`
	BitrateKbps pgtype.Int4 `json:"bitrate_kbps"`
	Preset      pgtype.Text `json:"preset"`
	Container   pgtype.Text `json:"container"`
	ConfigJson  []byte      `json:"config_json"`
}

func (q *Queries) CreateEncodingProfile(ctx context.Context, arg CreateEncodingProfileParams) (EncodingProfile, error) {
	row := q.db.QueryRow(ctx, createEncodingProfile,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.VideoCodec,
		arg.AudioCodec,
		arg.Width,
		arg.Height,
		arg.BitrateKbps,
		arg.Preset,
		arg.Container,
		arg.ConfigJson,
	)
	var i EncodingProfile
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.Width,
		&i.Height,
		&i.BitrateKbps,
		&i.Preset,
		&i.Container,
		&i.IsSystem,
		&i.ConfigJson,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createErrorEvent = `-- name: CreateErrorEvent :one

INSERT INTO error_events (source_component, severity, message, stack_trace, context_data)
VALUES ($1, $2::error_severity, $3, $4, $5)
RETURNING id, source_component, severity, message, stack_trace, context_data, resolved, created_at
`

type CreateErrorEventParams struct {
	SourceComponent string        `json:"source_component"`
	Column2         ErrorSeverity `json:"column_2"`
	Message         string        `json:"message"`
	StackTrace      pgtype.Text   `json:"stack_trace"`
	ContextData     []byte        `json:"context_data"`
}

// ============================================
// GLOBAL ERROR TRACKING
// ============================================
func (q *Queries) CreateErrorEvent(ctx context.Context, arg CreateErrorEventParams) (ErrorEvent, error) {
	row := q.db.QueryRow(ctx, createErrorEvent,
		arg.SourceComponent,
		arg.Column2,
		arg.Message,
		arg.StackTrace,
		arg.ContextData,
	)
	var i ErrorEvent
	err := row.Scan(
		&i.ID,
		&i.SourceComponent,
		&i.Severity,
		&i.Message,
		&i.StackTrace,
		&i.ContextData,
		&i.Resolved,
		&i.CreatedAt,
	)
	return i, err
}

const createJob = `-- name: CreateJob :one

INSERT INTO jobs (
    source_url, profiles, status, metadata, 
    user_id, source_type, profile_id, output_config
)
VALUES ($1, $2, 'queued', $3, $4, $5, $6, $7)
RETURNING id, source_url, profiles, status, created_at, updated_at, metadata, user_id, source_type, source_stream_id, profile_id, output_config, progress_pct, error_message, assigned_to_worker_id, started_at, finished_at, eta_seconds
`

type CreateJobParams struct {
	SourceUrl    string            `json:"source_url"`
	Profiles     []string          `json:"profiles"`
	Metadata     []byte            `json:"metadata"`
	UserID       pgtype.UUID       `json:"user_id"`
	SourceType   NullJobSourceType `json:"source_type"`
	ProfileID    pgtype.Text       `json:"profile_id"`
	OutputConfig []byte            `json:"output_config"`
}

// ============================================
// JOBS
// ============================================
func (q *Queries) CreateJob(ctx context.Context, arg CreateJobParams) (Job, error) {
	row := q.db.QueryRow(ctx, createJob,
		arg.SourceUrl,
		arg.Profiles,
		arg.Metadata,
		arg.UserID,
		arg.SourceType,
		arg.ProfileID,
		arg.OutputConfig,
	)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.SourceUrl,
		&i.Profiles,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Metadata,
		&i.UserID,
		&i.SourceType,
		&i.SourceStreamID,
		&i.ProfileID,
		&i.OutputConfig,
		&i.ProgressPct,
		&i.ErrorMessage,
		&i.AssignedToWorkerID,
		&i.StartedAt,
		&i.FinishedAt,
		&i.EtaSeconds,
	)
	return i, err
}

const createJobLog = `-- name: CreateJobLog :exec

INSERT INTO job_logs (job_id, level, message, metadata)
VALUES ($1, $2, $3, $4)
`

type CreateJobLogParams struct {
	JobID    pgtype.UUID `json:"job_id"`
	Level    string      `json:"level"`
	Message  string      `json:"message"`
	Metadata []byte      `json:"metadata"`
}

// ============================================
// JOB LOGS
// ============================================
func (q *Queries) CreateJobLog(ctx context.Context, arg CreateJobLogParams) error {
	_, err := q.db.Exec(ctx, createJobLog,
		arg.JobID,
		arg.Level,
		arg.Message,
		arg.Metadata,
	)
	return err
}

const createNotification = `-- name: CreateNotification :one

INSERT INTO notifications (user_id, title, message, link, type, is_read)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, user_id, title, message, link, type, is_read, created_at, expires_at
`

type CreateNotificationParams struct {
	UserID  pgtype.UUID `json:"user_id"`
	Title   string      `json:"title"`
	Message string      `json:"message"`
	Link    pgtype.Text `json:"link"`
	Type    pgtype.Text `json:"type"`
	IsRead  pgtype.Bool `json:"is_read"`
}

// ============================================
// NOTIFICATIONS
// ============================================
func (q *Queries) CreateNotification(ctx context.Context, arg CreateNotificationParams) (Notification, error) {
	row := q.db.QueryRow(ctx, createNotification,
		arg.UserID,
		arg.Title,
		arg.Message,
		arg.Link,
		arg.Type,
		arg.IsRead,
	)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Message,
		&i.Link,
		&i.Type,
		&i.IsRead,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const createRestreamJob = `-- name: CreateRestreamJob :one

INSERT INTO restream_jobs (user_id, title, description, input_type, input_url, output_destinations, schedule_type, schedule_config, loop_enabled, simulate_live)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id, user_id, title, description, input_type, input_url, output_destinations, schedule_type, schedule_config, loop_enabled, simulate_live, status, current_stats, created_at, updated_at, started_at, stopped_at
`

type CreateRestreamJobParams struct {
	UserID             pgtype.UUID `json:"user_id"`
	Title              pgtype.Text `json:"title"`
	Description        pgtype.Text `json:"description"`
	InputType          pgtype.Text `json:"input_type"`
	InputUrl           pgtype.Text `json:"input_url"`
	OutputDestinations []byte      `json:"output_destinations"`
	ScheduleType       pgtype.Text `json:"schedule_type"`
	ScheduleConfig     []byte      `json:"schedule_config"`
	LoopEnabled        pgtype.Bool `json:"loop_enabled"`
	SimulateLive       pgtype.Bool `json:"simulate_live"`
}

// ============================================
// RESTREAM JOBS
// ============================================
func (q *Queries) CreateRestreamJob(ctx context.Context, arg CreateRestreamJobParams) (RestreamJob, error) {
	row := q.db.QueryRow(ctx, createRestreamJob,
		arg.UserID,
		arg.Title,
		arg.Description,
		arg.InputType,
		arg.InputUrl,
		arg.OutputDestinations,
		arg.ScheduleType,
		arg.ScheduleConfig,
		arg.LoopEnabled,
		arg.SimulateLive,
	)
	var i RestreamJob
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.InputType,
		&i.InputUrl,
		&i.OutputDestinations,
		&i.ScheduleType,
		&i.ScheduleConfig,
		&i.LoopEnabled,
		&i.SimulateLive,
		&i.Status,
		&i.CurrentStats,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StartedAt,
		&i.StoppedAt,
	)
	return i, err
}

const createStream = `-- name: CreateStream :one

INSERT INTO streams (stream_key, user_id, title, description, archive_enabled, ingest_server)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, stream_key, is_live, ingest_url, playback_url, created_at, user_id, title, description, thumbnail_url, ingest_server, current_viewers, total_viewers_lifetime, started_at, ended_at, last_stats, archive_enabled, archive_vod_job_id, restream_destinations
`

type CreateStreamParams struct {
	StreamKey      string      `json:"stream_key"`
	UserID         pgtype.UUID `json:"user_id"`
	Title          pgtype.Text `json:"title"`
	Description    pgtype.Text `json:"description"`
	ArchiveEnabled pgtype.Bool `json:"archive_enabled"`
	IngestServer   pgtype.Text `json:"ingest_server"`
}

// ============================================
// STREAMS
// ============================================
func (q *Queries) CreateStream(ctx context.Context, arg CreateStreamParams) (Stream, error) {
	row := q.db.QueryRow(ctx, createStream,
		arg.StreamKey,
		arg.UserID,
		arg.Title,
		arg.Description,
		arg.ArchiveEnabled,
		arg.IngestServer,
	)
	var i Stream
	err := row.Scan(
		&i.ID,
		&i.StreamKey,
		&i.IsLive,
		&i.IngestUrl,
		&i.PlaybackUrl,
		&i.CreatedAt,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.ThumbnailUrl,
		&i.IngestServer,
		&i.CurrentViewers,
		&i.TotalViewersLifetime,
		&i.StartedAt,
		&i.EndedAt,
		&i.LastStats,
		&i.ArchiveEnabled,
		&i.ArchiveVodJobID,
		&i.RestreamDestinations,
	)
	return i, err
}

const createTask = `-- name: CreateTask :one

INSERT INTO tasks (job_id, type, status, params, sequence_index, start_time_sec, end_time_sec)
VALUES ($1, $2, 'pending', $3, $4, $5, $6)
RETURNING id, job_id, type, status, params, worker_id, result, created_at, updated_at, sequence_index, start_time_sec, end_time_sec, attempt_count, max_attempts, output_key, output_size_bytes
`

type CreateTaskParams struct {
	JobID         pgtype.UUID   `json:"job_id"`
	Type          TaskType      `json:"type"`
	Params        []byte        `json:"params"`
	SequenceIndex pgtype.Int4   `json:"sequence_index"`
	StartTimeSec  pgtype.Float8 `json:"start_time_sec"`
	EndTimeSec    pgtype.Float8 `json:"end_time_sec"`
}

// ============================================
// TASKS
// ============================================
func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) (Task, error) {
	row := q.db.QueryRow(ctx, createTask,
		arg.JobID,
		arg.Type,
		arg.Params,
		arg.SequenceIndex,
		arg.StartTimeSec,
		arg.EndTimeSec,
	)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.Type,
		&i.Status,
		&i.Params,
		&i.WorkerID,
		&i.Result,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SequenceIndex,
		&i.StartTimeSec,
		&i.EndTimeSec,
		&i.AttemptCount,
		&i.MaxAttempts,
		&i.OutputKey,
		&i.OutputSizeBytes,
	)
	return i, err
}

const createWebhook = `-- name: CreateWebhook :one

INSERT INTO webhooks (user_id, url, secret, events)
VALUES ($1, $2, $3, $4)
RETURNING id, user_id, url, secret, events, is_active, last_triggered_at, failure_count, created_at, updated_at
`

type CreateWebhookParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Url    string      `json:"url"`
	Secret string      `json:"secret"`
	Events []string    `json:"events"`
}

// ============================================
// WEBHOOKS
// ============================================
func (q *Queries) CreateWebhook(ctx context.Context, arg CreateWebhookParams) (Webhook, error) {
	row := q.db.QueryRow(ctx, createWebhook,
		arg.UserID,
		arg.Url,
		arg.Secret,
		arg.Events,
	)
	var i Webhook
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Url,
		&i.Secret,
		&i.Events,
		&i.IsActive,
		&i.LastTriggeredAt,
		&i.FailureCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deactivateWebhook = `-- name: DeactivateWebhook :exec
UPDATE webhooks
SET is_active = FALSE, updated_at = NOW()
WHERE id = $1
`

func (q *Queries) DeactivateWebhook(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deactivateWebhook, id)
	return err
}

const deleteEncodingProfile = `-- name: DeleteEncodingProfile :exec
DELETE FROM encoding_profiles WHERE id = $1 AND is_system = FALSE
`

func (q *Queries) DeleteEncodingProfile(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteEncodingProfile, id)
	return err
}

const deleteJob = `-- name: DeleteJob :exec
DELETE FROM jobs WHERE id = $1
`

func (q *Queries) DeleteJob(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteJob, id)
	return err
}

const deleteNotification = `-- name: DeleteNotification :exec
DELETE FROM notifications
WHERE id = $1 AND user_id = $2
`

type DeleteNotificationParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) DeleteNotification(ctx context.Context, arg DeleteNotificationParams) error {
	_, err := q.db.Exec(ctx, deleteNotification, arg.ID, arg.UserID)
	return err
}

const deleteOldAuditLogs = `-- name: DeleteOldAuditLogs :execrows
DELETE FROM audit_log 
WHERE created_at < $1
`

func (q *Queries) DeleteOldAuditLogs(ctx context.Context, createdAt pgtype.Timestamptz) (int64, error) {
	result, err := q.db.Exec(ctx, deleteOldAuditLogs, createdAt)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteOldErrorEvents = `-- name: DeleteOldErrorEvents :execrows
DELETE FROM error_events
WHERE created_at < $1
`

func (q *Queries) DeleteOldErrorEvents(ctx context.Context, createdAt pgtype.Timestamptz) (int64, error) {
	result, err := q.db.Exec(ctx, deleteOldErrorEvents, createdAt)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteOldJobsByStatus = `-- name: DeleteOldJobsByStatus :execrows

DELETE FROM jobs 
WHERE status = $1 AND created_at < $2
`

type DeleteOldJobsByStatusParams struct {
	Status    JobStatus          `json:"status"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

// ============================================
// CLEANUP QUERIES
// ============================================
func (q *Queries) DeleteOldJobsByStatus(ctx context.Context, arg DeleteOldJobsByStatusParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteOldJobsByStatus, arg.Status, arg.CreatedAt)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteOldNotifications = `-- name: DeleteOldNotifications :exec
DELETE FROM notifications
WHERE user_id = $1 AND created_at < NOW() - INTERVAL '30 days'
`

func (q *Queries) DeleteOldNotifications(ctx context.Context, userID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteOldNotifications, userID)
	return err
}

const deleteOldWorkers = `-- name: DeleteOldWorkers :execrows
DELETE FROM workers
WHERE is_healthy = FALSE AND last_seen < $1
`

func (q *Queries) DeleteOldWorkers(ctx context.Context, lastSeen pgtype.Timestamptz) (int64, error) {
	result, err := q.db.Exec(ctx, deleteOldWorkers, lastSeen)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteOrphanedTasks = `-- name: DeleteOrphanedTasks :execrows
DELETE FROM tasks 
WHERE job_id NOT IN (SELECT id FROM jobs)
`

func (q *Queries) DeleteOrphanedTasks(ctx context.Context) (int64, error) {
	result, err := q.db.Exec(ctx, deleteOrphanedTasks)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deletePluginConfig = `-- name: DeletePluginConfig :exec
DELETE FROM plugin_configs WHERE id = $1
`

func (q *Queries) DeletePluginConfig(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deletePluginConfig, id)
	return err
}

const deleteRestreamJob = `-- name: DeleteRestreamJob :exec
DELETE FROM restream_jobs WHERE id = $1
`

func (q *Queries) DeleteRestreamJob(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteRestreamJob, id)
	return err
}

const deleteStream = `-- name: DeleteStream :exec
DELETE FROM streams WHERE id = $1
`

func (q *Queries) DeleteStream(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteStream, id)
	return err
}

const deleteWebhook = `-- name: DeleteWebhook :exec
DELETE FROM webhooks WHERE id = $1
`

func (q *Queries) DeleteWebhook(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteWebhook, id)
	return err
}

const deleteWorker = `-- name: DeleteWorker :exec
DELETE FROM workers WHERE id = $1
`

func (q *Queries) DeleteWorker(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteWorker, id)
	return err
}

const disablePlugin = `-- name: DisablePlugin :exec
UPDATE plugin_configs
SET is_enabled = FALSE, updated_at = NOW()
WHERE id = $1
`

func (q *Queries) DisablePlugin(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, disablePlugin, id)
	return err
}

const enablePlugin = `-- name: EnablePlugin :exec
UPDATE plugin_configs
SET is_enabled = TRUE, updated_at = NOW()
WHERE id = $1
`

func (q *Queries) EnablePlugin(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, enablePlugin, id)
	return err
}

const failTask = `-- name: FailTask :exec
UPDATE tasks
SET status = 'failed', result = $2, attempt_count = attempt_count + 1, updated_at = NOW()
WHERE id = $1
`

type FailTaskParams struct {
	ID     pgtype.UUID `json:"id"`
	Result []byte      `json:"result"`
}

func (q *Queries) FailTask(ctx context.Context, arg FailTaskParams) error {
	_, err := q.db.Exec(ctx, failTask, arg.ID, arg.Result)
	return err
}

const getCompletedTaskOutputs = `-- name: GetCompletedTaskOutputs :many
SELECT output_key, sequence_index FROM tasks
WHERE job_id = $1 AND status = 'completed'
ORDER BY sequence_index ASC
`

type GetCompletedTaskOutputsRow struct {
	OutputKey     pgtype.Text `json:"output_key"`
	SequenceIndex pgtype.Int4 `json:"sequence_index"`
}

func (q *Queries) GetCompletedTaskOutputs(ctx context.Context, jobID pgtype.UUID) ([]GetCompletedTaskOutputsRow, error) {
	rows, err := q.db.Query(ctx, getCompletedTaskOutputs, jobID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCompletedTaskOutputsRow
	for rows.Next() {
		var i GetCompletedTaskOutputsRow
		if err := rows.Scan(&i.OutputKey, &i.SequenceIndex); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEncodingProfile = `-- name: GetEncodingProfile :one

SELECT id, name, description, video_codec, audio_codec, width, height, bitrate_kbps, preset, container, is_system, config_json, created_at, updated_at FROM encoding_profiles WHERE id = $1 LIMIT 1
`

// ============================================
// ENCODING PROFILES
// ============================================
func (q *Queries) GetEncodingProfile(ctx context.Context, id string) (EncodingProfile, error) {
	row := q.db.QueryRow(ctx, getEncodingProfile, id)
	var i EncodingProfile
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.VideoCodec,
		&i.AudioCodec,
		&i.Width,
		&i.Height,
		&i.BitrateKbps,
		&i.Preset,
		&i.Container,
		&i.IsSystem,
		&i.ConfigJson,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getJob = `-- name: GetJob :one
SELECT id, source_url, profiles, status, created_at, updated_at, metadata, user_id, source_type, source_stream_id, profile_id, output_config, progress_pct, error_message, assigned_to_worker_id, started_at, finished_at, eta_seconds FROM jobs
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetJob(ctx context.Context, id pgtype.UUID) (Job, error) {
	row := q.db.QueryRow(ctx, getJob, id)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.SourceUrl,
		&i.Profiles,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Metadata,
		&i.UserID,
		&i.SourceType,
		&i.SourceStreamID,
		&i.ProfileID,
		&i.OutputConfig,
		&i.ProgressPct,
		&i.ErrorMessage,
		&i.AssignedToWorkerID,
		&i.StartedAt,
		&i.FinishedAt,
		&i.EtaSeconds,
	)
	return i, err
}

const getPendingTasks = `-- name: GetPendingTasks :many
SELECT id, job_id, type, status, params, worker_id, result, created_at, updated_at, sequence_index, start_time_sec, end_time_sec, attempt_count, max_attempts, output_key, output_size_bytes FROM tasks
WHERE status = 'pending'
ORDER BY created_at ASC
LIMIT $1
`

func (q *Queries) GetPendingTasks(ctx context.Context, limit int32) ([]Task, error) {
	rows, err := q.db.Query(ctx, getPendingTasks, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.Type,
			&i.Status,
			&i.Params,
			&i.WorkerID,
			&i.Result,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SequenceIndex,
			&i.StartTimeSec,
			&i.EndTimeSec,
			&i.AttemptCount,
			&i.MaxAttempts,
			&i.OutputKey,
			&i.OutputSizeBytes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluginConfig = `-- name: GetPluginConfig :one
SELECT id, plugin_type, config_json, is_enabled, priority, created_at, updated_at FROM plugin_configs WHERE id = $1 LIMIT 1
`

func (q *Queries) GetPluginConfig(ctx context.Context, id string) (PluginConfig, error) {
	row := q.db.QueryRow(ctx, getPluginConfig, id)
	var i PluginConfig
	err := row.Scan(
		&i.ID,
		&i.PluginType,
		&i.ConfigJson,
		&i.IsEnabled,
		&i.Priority,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRestreamJob = `-- name: GetRestreamJob :one
SELECT id, user_id, title, description, input_type, input_url, output_destinations, schedule_type, schedule_config, loop_enabled, simulate_live, status, current_stats, created_at, updated_at, started_at, stopped_at FROM restream_jobs WHERE id = $1 LIMIT 1
`

func (q *Queries) GetRestreamJob(ctx context.Context, id pgtype.UUID) (RestreamJob, error) {
	row := q.db.QueryRow(ctx, getRestreamJob, id)
	var i RestreamJob
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.InputType,
		&i.InputUrl,
		&i.OutputDestinations,
		&i.ScheduleType,
		&i.ScheduleConfig,
		&i.LoopEnabled,
		&i.SimulateLive,
		&i.Status,
		&i.CurrentStats,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StartedAt,
		&i.StoppedAt,
	)
	return i, err
}

const getStream = `-- name: GetStream :one
SELECT id, stream_key, is_live, ingest_url, playback_url, created_at, user_id, title, description, thumbnail_url, ingest_server, current_viewers, total_viewers_lifetime, started_at, ended_at, last_stats, archive_enabled, archive_vod_job_id, restream_destinations FROM streams WHERE id = $1 LIMIT 1
`

func (q *Queries) GetStream(ctx context.Context, id pgtype.UUID) (Stream, error) {
	row := q.db.QueryRow(ctx, getStream, id)
	var i Stream
	err := row.Scan(
		&i.ID,
		&i.StreamKey,
		&i.IsLive,
		&i.IngestUrl,
		&i.PlaybackUrl,
		&i.CreatedAt,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.ThumbnailUrl,
		&i.IngestServer,
		&i.CurrentViewers,
		&i.TotalViewersLifetime,
		&i.StartedAt,
		&i.EndedAt,
		&i.LastStats,
		&i.ArchiveEnabled,
		&i.ArchiveVodJobID,
		&i.RestreamDestinations,
	)
	return i, err
}

const getStreamByKey = `-- name: GetStreamByKey :one
SELECT id, stream_key, is_live, ingest_url, playback_url, created_at, user_id, title, description, thumbnail_url, ingest_server, current_viewers, total_viewers_lifetime, started_at, ended_at, last_stats, archive_enabled, archive_vod_job_id, restream_destinations FROM streams WHERE stream_key = $1 LIMIT 1
`

func (q *Queries) GetStreamByKey(ctx context.Context, streamKey string) (Stream, error) {
	row := q.db.QueryRow(ctx, getStreamByKey, streamKey)
	var i Stream
	err := row.Scan(
		&i.ID,
		&i.StreamKey,
		&i.IsLive,
		&i.IngestUrl,
		&i.PlaybackUrl,
		&i.CreatedAt,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.ThumbnailUrl,
		&i.IngestServer,
		&i.CurrentViewers,
		&i.TotalViewersLifetime,
		&i.StartedAt,
		&i.EndedAt,
		&i.LastStats,
		&i.ArchiveEnabled,
		&i.ArchiveVodJobID,
		&i.RestreamDestinations,
	)
	return i, err
}

const getTask = `-- name: GetTask :one
SELECT id, job_id, type, status, params, worker_id, result, created_at, updated_at, sequence_index, start_time_sec, end_time_sec, attempt_count, max_attempts, output_key, output_size_bytes FROM tasks WHERE id = $1 LIMIT 1
`

func (q *Queries) GetTask(ctx context.Context, id pgtype.UUID) (Task, error) {
	row := q.db.QueryRow(ctx, getTask, id)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.Type,
		&i.Status,
		&i.Params,
		&i.WorkerID,
		&i.Result,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SequenceIndex,
		&i.StartTimeSec,
		&i.EndTimeSec,
		&i.AttemptCount,
		&i.MaxAttempts,
		&i.OutputKey,
		&i.OutputSizeBytes,
	)
	return i, err
}

const getUnreadNotificationCount = `-- name: GetUnreadNotificationCount :one
SELECT COUNT(*) FROM notifications
WHERE user_id = $1 AND is_read = FALSE
`

func (q *Queries) GetUnreadNotificationCount(ctx context.Context, userID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getUnreadNotificationCount, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getWebhook = `-- name: GetWebhook :one
SELECT id, user_id, url, secret, events, is_active, last_triggered_at, failure_count, created_at, updated_at FROM webhooks WHERE id = $1 LIMIT 1
`

func (q *Queries) GetWebhook(ctx context.Context, id pgtype.UUID) (Webhook, error) {
	row := q.db.QueryRow(ctx, getWebhook, id)
	var i Webhook
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Url,
		&i.Secret,
		&i.Events,
		&i.IsActive,
		&i.LastTriggeredAt,
		&i.FailureCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWorker = `-- name: GetWorker :one
SELECT id, hostname, version, last_seen, status, capacity, ip_address, port, capabilities, is_healthy, created_at FROM workers WHERE id = $1 LIMIT 1
`

func (q *Queries) GetWorker(ctx context.Context, id string) (Worker, error) {
	row := q.db.QueryRow(ctx, getWorker, id)
	var i Worker
	err := row.Scan(
		&i.ID,
		&i.Hostname,
		&i.Version,
		&i.LastSeen,
		&i.Status,
		&i.Capacity,
		&i.IpAddress,
		&i.Port,
		&i.Capabilities,
		&i.IsHealthy,
		&i.CreatedAt,
	)
	return i, err
}

const incrementTaskAttempt = `-- name: IncrementTaskAttempt :exec
UPDATE tasks
SET attempt_count = attempt_count + 1, updated_at = NOW()
WHERE id = $1
`

func (q *Queries) IncrementTaskAttempt(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, incrementTaskAttempt, id)
	return err
}

const incrementWebhookFailure = `-- name: IncrementWebhookFailure :exec
UPDATE webhooks
SET failure_count = failure_count + 1, updated_at = NOW()
WHERE id = $1
`

func (q *Queries) IncrementWebhookFailure(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, incrementWebhookFailure, id)
	return err
}

const listActiveWebhooksForEvent = `-- name: ListActiveWebhooksForEvent :many
SELECT id, user_id, url, secret, events, is_active, last_triggered_at, failure_count, created_at, updated_at FROM webhooks
WHERE is_active = TRUE AND $1::TEXT = ANY(events)
`

func (q *Queries) ListActiveWebhooksForEvent(ctx context.Context, event string) ([]Webhook, error) {
	rows, err := q.db.Query(ctx, listActiveWebhooksForEvent, event)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Webhook
	for rows.Next() {
		var i Webhook
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Url,
			&i.Secret,
			&i.Events,
			&i.IsActive,
			&i.LastTriggeredAt,
			&i.FailureCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditLogs = `-- name: ListAuditLogs :many
SELECT id, user_id, action, resource_type, resource_id, details, ip_address, user_agent, created_at FROM audit_log
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListAuditLogsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListAuditLogs(ctx context.Context, arg ListAuditLogsParams) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, listAuditLogs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuditLog
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Action,
			&i.ResourceType,
			&i.ResourceID,
			&i.Details,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditLogsByUser = `-- name: ListAuditLogsByUser :many
SELECT id, user_id, action, resource_type, resource_id, details, ip_address, user_agent, created_at FROM audit_log
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListAuditLogsByUserParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

func (q *Queries) ListAuditLogsByUser(ctx context.Context, arg ListAuditLogsByUserParams) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, listAuditLogsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuditLog
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Action,
			&i.ResourceType,
			&i.ResourceID,
			&i.Details,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEncodingProfiles = `-- name: ListEncodingProfiles :many
SELECT id, name, description, video_codec, audio_codec, width, height, bitrate_kbps, preset, container, is_system, config_json, created_at, updated_at FROM encoding_profiles
ORDER BY is_system DESC, name ASC
`

func (q *Queries) ListEncodingProfiles(ctx context.Context) ([]EncodingProfile, error) {
	rows, err := q.db.Query(ctx, listEncodingProfiles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EncodingProfile
	for rows.Next() {
		var i EncodingProfile
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.VideoCodec,
			&i.AudioCodec,
			&i.Width,
			&i.Height,
			&i.BitrateKbps,
			&i.Preset,
			&i.Container,
			&i.IsSystem,
			&i.ConfigJson,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listErrorEvents = `-- name: ListErrorEvents :many
SELECT id, source_component, severity, message, stack_trace, context_data, resolved, created_at FROM error_events
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListErrorEventsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListErrorEvents(ctx context.Context, arg ListErrorEventsParams) ([]ErrorEvent, error) {
	rows, err := q.db.Query(ctx, listErrorEvents, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ErrorEvent
	for rows.Next() {
		var i ErrorEvent
		if err := rows.Scan(
			&i.ID,
			&i.SourceComponent,
			&i.Severity,
			&i.Message,
			&i.StackTrace,
			&i.ContextData,
			&i.Resolved,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listErrorEventsBySource = `-- name: ListErrorEventsBySource :many
SELECT id, source_component, severity, message, stack_trace, context_data, resolved, created_at FROM error_events
WHERE source_component = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListErrorEventsBySourceParams struct {
	SourceComponent string `json:"source_component"`
	Limit           int32  `json:"limit"`
	Offset          int32  `json:"offset"`
}

func (q *Queries) ListErrorEventsBySource(ctx context.Context, arg ListErrorEventsBySourceParams) ([]ErrorEvent, error) {
	rows, err := q.db.Query(ctx, listErrorEventsBySource, arg.SourceComponent, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ErrorEvent
	for rows.Next() {
		var i ErrorEvent
		if err := rows.Scan(
			&i.ID,
			&i.SourceComponent,
			&i.Severity,
			&i.Message,
			&i.StackTrace,
			&i.ContextData,
			&i.Resolved,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listHealthyWorkers = `-- name: ListHealthyWorkers :many
SELECT id, hostname, version, last_seen, status, capacity, ip_address, port, capabilities, is_healthy, created_at FROM workers
WHERE is_healthy = TRUE
ORDER BY last_seen DESC
`

func (q *Queries) ListHealthyWorkers(ctx context.Context) ([]Worker, error) {
	rows, err := q.db.Query(ctx, listHealthyWorkers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Worker
	for rows.Next() {
		var i Worker
		if err := rows.Scan(
			&i.ID,
			&i.Hostname,
			&i.Version,
			&i.LastSeen,
			&i.Status,
			&i.Capacity,
			&i.IpAddress,
			&i.Port,
			&i.Capabilities,
			&i.IsHealthy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listJobLogs = `-- name: ListJobLogs :many
SELECT id, job_id, level, message, metadata, created_at FROM job_logs
WHERE job_id = $1
ORDER BY created_at ASC
`

func (q *Queries) ListJobLogs(ctx context.Context, jobID pgtype.UUID) ([]JobLog, error) {
	rows, err := q.db.Query(ctx, listJobLogs, jobID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []JobLog
	for rows.Next() {
		var i JobLog
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.Level,
			&i.Message,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listJobs = `-- name: ListJobs :many
SELECT id, source_url, profiles, status, created_at, updated_at, metadata, user_id, source_type, source_stream_id, profile_id, output_config, progress_pct, error_message, assigned_to_worker_id, started_at, finished_at, eta_seconds FROM jobs
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListJobsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListJobs(ctx context.Context, arg ListJobsParams) ([]Job, error) {
	rows, err := q.db.Query(ctx, listJobs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Job
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.ID,
			&i.SourceUrl,
			&i.Profiles,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Metadata,
			&i.UserID,
			&i.SourceType,
			&i.SourceStreamID,
			&i.ProfileID,
			&i.OutputConfig,
			&i.ProgressPct,
			&i.ErrorMessage,
			&i.AssignedToWorkerID,
			&i.StartedAt,
			&i.FinishedAt,
			&i.EtaSeconds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listJobsByStatus = `-- name: ListJobsByStatus :many
SELECT id, source_url, profiles, status, created_at, updated_at, metadata, user_id, source_type, source_stream_id, profile_id, output_config, progress_pct, error_message, assigned_to_worker_id, started_at, finished_at, eta_seconds FROM jobs
WHERE status = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListJobsByStatusParams struct {
	Status JobStatus `json:"status"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

func (q *Queries) ListJobsByStatus(ctx context.Context, arg ListJobsByStatusParams) ([]Job, error) {
	rows, err := q.db.Query(ctx, listJobsByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Job
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.ID,
			&i.SourceUrl,
			&i.Profiles,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Metadata,
			&i.UserID,
			&i.SourceType,
			&i.SourceStreamID,
			&i.ProfileID,
			&i.OutputConfig,
			&i.ProgressPct,
			&i.ErrorMessage,
			&i.AssignedToWorkerID,
			&i.StartedAt,
			&i.FinishedAt,
			&i.EtaSeconds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listJobsByUser = `-- name: ListJobsByUser :many
SELECT id, source_url, profiles, status, created_at, updated_at, metadata, user_id, source_type, source_stream_id, profile_id, output_config, progress_pct, error_message, assigned_to_worker_id, started_at, finished_at, eta_seconds FROM jobs
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListJobsByUserParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

func (q *Queries) ListJobsByUser(ctx context.Context, arg ListJobsByUserParams) ([]Job, error) {
	rows, err := q.db.Query(ctx, listJobsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Job
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.ID,
			&i.SourceUrl,
			&i.Profiles,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Metadata,
			&i.UserID,
			&i.SourceType,
			&i.SourceStreamID,
			&i.ProfileID,
			&i.OutputConfig,
			&i.ProgressPct,
			&i.ErrorMessage,
			&i.AssignedToWorkerID,
			&i.StartedAt,
			&i.FinishedAt,
			&i.EtaSeconds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLiveStreams = `-- name: ListLiveStreams :many
SELECT id, stream_key, is_live, ingest_url, playback_url, created_at, user_id, title, description, thumbnail_url, ingest_server, current_viewers, total_viewers_lifetime, started_at, ended_at, last_stats, archive_enabled, archive_vod_job_id, restream_destinations FROM streams
WHERE is_live = TRUE
ORDER BY started_at DESC
`

func (q *Queries) ListLiveStreams(ctx context.Context) ([]Stream, error) {
	rows, err := q.db.Query(ctx, listLiveStreams)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Stream
	for rows.Next() {
		var i Stream
		if err := rows.Scan(
			&i.ID,
			&i.StreamKey,
			&i.IsLive,
			&i.IngestUrl,
			&i.PlaybackUrl,
			&i.CreatedAt,
			&i.UserID,
			&i.Title,
			&i.Description,
			&i.ThumbnailUrl,
			&i.IngestServer,
			&i.CurrentViewers,
			&i.TotalViewersLifetime,
			&i.StartedAt,
			&i.EndedAt,
			&i.LastStats,
			&i.ArchiveEnabled,
			&i.ArchiveVodJobID,
			&i.RestreamDestinations,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNotifications = `-- name: ListNotifications :many
SELECT id, user_id, title, message, link, type, is_read, created_at, expires_at FROM notifications
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListNotificationsParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

func (q *Queries) ListNotifications(ctx context.Context, arg ListNotificationsParams) ([]Notification, error) {
	rows, err := q.db.Query(ctx, listNotifications, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Message,
			&i.Link,
			&i.Type,
			&i.IsRead,
			&i.CreatedAt,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPluginConfigs = `-- name: ListPluginConfigs :many
SELECT id, plugin_type, config_json, is_enabled, priority, created_at, updated_at FROM plugin_configs
ORDER BY plugin_type, priority DESC
`

func (q *Queries) ListPluginConfigs(ctx context.Context) ([]PluginConfig, error) {
	rows, err := q.db.Query(ctx, listPluginConfigs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PluginConfig
	for rows.Next() {
		var i PluginConfig
		if err := rows.Scan(
			&i.ID,
			&i.PluginType,
			&i.ConfigJson,
			&i.IsEnabled,
			&i.Priority,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPluginConfigsByType = `-- name: ListPluginConfigsByType :many
SELECT id, plugin_type, config_json, is_enabled, priority, created_at, updated_at FROM plugin_configs
WHERE plugin_type = $1
ORDER BY priority DESC
`

func (q *Queries) ListPluginConfigsByType(ctx context.Context, pluginType string) ([]PluginConfig, error) {
	rows, err := q.db.Query(ctx, listPluginConfigsByType, pluginType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PluginConfig
	for rows.Next() {
		var i PluginConfig
		if err := rows.Scan(
			&i.ID,
			&i.PluginType,
			&i.ConfigJson,
			&i.IsEnabled,
			&i.Priority,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRestreamJobs = `-- name: ListRestreamJobs :many
SELECT id, user_id, title, description, input_type, input_url, output_destinations, schedule_type, schedule_config, loop_enabled, simulate_live, status, current_stats, created_at, updated_at, started_at, stopped_at FROM restream_jobs
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListRestreamJobsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListRestreamJobs(ctx context.Context, arg ListRestreamJobsParams) ([]RestreamJob, error) {
	rows, err := q.db.Query(ctx, listRestreamJobs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RestreamJob
	for rows.Next() {
		var i RestreamJob
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Description,
			&i.InputType,
			&i.InputUrl,
			&i.OutputDestinations,
			&i.ScheduleType,
			&i.ScheduleConfig,
			&i.LoopEnabled,
			&i.SimulateLive,
			&i.Status,
			&i.CurrentStats,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StartedAt,
			&i.StoppedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRestreamJobsByUser = `-- name: ListRestreamJobsByUser :many
SELECT id, user_id, title, description, input_type, input_url, output_destinations, schedule_type, schedule_config, loop_enabled, simulate_live, status, current_stats, created_at, updated_at, started_at, stopped_at FROM restream_jobs
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListRestreamJobsByUserParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

func (q *Queries) ListRestreamJobsByUser(ctx context.Context, arg ListRestreamJobsByUserParams) ([]RestreamJob, error) {
	rows, err := q.db.Query(ctx, listRestreamJobsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RestreamJob
	for rows.Next() {
		var i RestreamJob
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Description,
			&i.InputType,
			&i.InputUrl,
			&i.OutputDestinations,
			&i.ScheduleType,
			&i.ScheduleConfig,
			&i.LoopEnabled,
			&i.SimulateLive,
			&i.Status,
			&i.CurrentStats,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StartedAt,
			&i.StoppedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStreams = `-- name: ListStreams :many
SELECT id, stream_key, is_live, ingest_url, playback_url, created_at, user_id, title, description, thumbnail_url, ingest_server, current_viewers, total_viewers_lifetime, started_at, ended_at, last_stats, archive_enabled, archive_vod_job_id, restream_destinations FROM streams
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListStreamsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListStreams(ctx context.Context, arg ListStreamsParams) ([]Stream, error) {
	rows, err := q.db.Query(ctx, listStreams, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Stream
	for rows.Next() {
		var i Stream
		if err := rows.Scan(
			&i.ID,
			&i.StreamKey,
			&i.IsLive,
			&i.IngestUrl,
			&i.PlaybackUrl,
			&i.CreatedAt,
			&i.UserID,
			&i.Title,
			&i.Description,
			&i.ThumbnailUrl,
			&i.IngestServer,
			&i.CurrentViewers,
			&i.TotalViewersLifetime,
			&i.StartedAt,
			&i.EndedAt,
			&i.LastStats,
			&i.ArchiveEnabled,
			&i.ArchiveVodJobID,
			&i.RestreamDestinations,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStreamsByUser = `-- name: ListStreamsByUser :many
SELECT id, stream_key, is_live, ingest_url, playback_url, created_at, user_id, title, description, thumbnail_url, ingest_server, current_viewers, total_viewers_lifetime, started_at, ended_at, last_stats, archive_enabled, archive_vod_job_id, restream_destinations FROM streams
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListStreamsByUserParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

func (q *Queries) ListStreamsByUser(ctx context.Context, arg ListStreamsByUserParams) ([]Stream, error) {
	rows, err := q.db.Query(ctx, listStreamsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Stream
	for rows.Next() {
		var i Stream
		if err := rows.Scan(
			&i.ID,
			&i.StreamKey,
			&i.IsLive,
			&i.IngestUrl,
			&i.PlaybackUrl,
			&i.CreatedAt,
			&i.UserID,
			&i.Title,
			&i.Description,
			&i.ThumbnailUrl,
			&i.IngestServer,
			&i.CurrentViewers,
			&i.TotalViewersLifetime,
			&i.StartedAt,
			&i.EndedAt,
			&i.LastStats,
			&i.ArchiveEnabled,
			&i.ArchiveVodJobID,
			&i.RestreamDestinations,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasksByJob = `-- name: ListTasksByJob :many
SELECT id, job_id, type, status, params, worker_id, result, created_at, updated_at, sequence_index, start_time_sec, end_time_sec, attempt_count, max_attempts, output_key, output_size_bytes FROM tasks
WHERE job_id = $1
ORDER BY sequence_index ASC
`

func (q *Queries) ListTasksByJob(ctx context.Context, jobID pgtype.UUID) ([]Task, error) {
	rows, err := q.db.Query(ctx, listTasksByJob, jobID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.Type,
			&i.Status,
			&i.Params,
			&i.WorkerID,
			&i.Result,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SequenceIndex,
			&i.StartTimeSec,
			&i.EndTimeSec,
			&i.AttemptCount,
			&i.MaxAttempts,
			&i.OutputKey,
			&i.OutputSizeBytes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWebhooks = `-- name: ListWebhooks :many
SELECT id, user_id, url, secret, events, is_active, last_triggered_at, failure_count, created_at, updated_at FROM webhooks
ORDER BY created_at DESC
`

func (q *Queries) ListWebhooks(ctx context.Context) ([]Webhook, error) {
	rows, err := q.db.Query(ctx, listWebhooks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Webhook
	for rows.Next() {
		var i Webhook
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Url,
			&i.Secret,
			&i.Events,
			&i.IsActive,
			&i.LastTriggeredAt,
			&i.FailureCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWebhooksByUser = `-- name: ListWebhooksByUser :many
SELECT id, user_id, url, secret, events, is_active, last_triggered_at, failure_count, created_at, updated_at FROM webhooks
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListWebhooksByUser(ctx context.Context, userID pgtype.UUID) ([]Webhook, error) {
	rows, err := q.db.Query(ctx, listWebhooksByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Webhook
	for rows.Next() {
		var i Webhook
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Url,
			&i.Secret,
			&i.Events,
			&i.IsActive,
			&i.LastTriggeredAt,
			&i.FailureCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkers = `-- name: ListWorkers :many
SELECT id, hostname, version, last_seen, status, capacity, ip_address, port, capabilities, is_healthy, created_at FROM workers
ORDER BY last_seen DESC
`

func (q *Queries) ListWorkers(ctx context.Context) ([]Worker, error) {
	rows, err := q.db.Query(ctx, listWorkers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Worker
	for rows.Next() {
		var i Worker
		if err := rows.Scan(
			&i.ID,
			&i.Hostname,
			&i.Version,
			&i.LastSeen,
			&i.Status,
			&i.Capacity,
			&i.IpAddress,
			&i.Port,
			&i.Capabilities,
			&i.IsHealthy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markAllNotificationsRead = `-- name: MarkAllNotificationsRead :exec
UPDATE notifications
SET is_read = TRUE
WHERE user_id = $1
`

func (q *Queries) MarkAllNotificationsRead(ctx context.Context, userID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, markAllNotificationsRead, userID)
	return err
}

const markNotificationRead = `-- name: MarkNotificationRead :exec
UPDATE notifications
SET is_read = TRUE
WHERE id = $1 AND user_id = $2
`

type MarkNotificationReadParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) MarkNotificationRead(ctx context.Context, arg MarkNotificationReadParams) error {
	_, err := q.db.Exec(ctx, markNotificationRead, arg.ID, arg.UserID)
	return err
}

const markWorkersUnhealthy = `-- name: MarkWorkersUnhealthy :many
UPDATE workers
SET is_healthy = FALSE
WHERE is_healthy = TRUE AND last_seen < NOW() - INTERVAL '30 seconds'
RETURNING id, hostname, version, last_seen, status, capacity, ip_address, port, capabilities, is_healthy, created_at
`

func (q *Queries) MarkWorkersUnhealthy(ctx context.Context) ([]Worker, error) {
	rows, err := q.db.Query(ctx, markWorkersUnhealthy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Worker
	for rows.Next() {
		var i Worker
		if err := rows.Scan(
			&i.ID,
			&i.Hostname,
			&i.Version,
			&i.LastSeen,
			&i.Status,
			&i.Capacity,
			&i.IpAddress,
			&i.Port,
			&i.Capabilities,
			&i.IsHealthy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const registerPluginConfig = `-- name: RegisterPluginConfig :one

INSERT INTO plugin_configs (id, plugin_type, config_json, is_enabled, priority)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (id) DO UPDATE
SET plugin_type = EXCLUDED.plugin_type, updated_at = NOW()
RETURNING id, plugin_type, config_json, is_enabled, priority, created_at, updated_at
`

type RegisterPluginConfigParams struct {
	ID         string      `json:"id"`
	PluginType string      `json:"plugin_type"`
	ConfigJson []byte      `json:"config_json"`
	IsEnabled  pgtype.Bool `json:"is_enabled"`
	Priority   pgtype.Int4 `json:"priority"`
}

// ============================================
// PLUGIN CONFIGS
// ============================================
func (q *Queries) RegisterPluginConfig(ctx context.Context, arg RegisterPluginConfigParams) (PluginConfig, error) {
	row := q.db.QueryRow(ctx, registerPluginConfig,
		arg.ID,
		arg.PluginType,
		arg.ConfigJson,
		arg.IsEnabled,
		arg.Priority,
	)
	var i PluginConfig
	err := row.Scan(
		&i.ID,
		&i.PluginType,
		&i.ConfigJson,
		&i.IsEnabled,
		&i.Priority,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const registerWorker = `-- name: RegisterWorker :exec

INSERT INTO workers (id, hostname, version, last_seen, status, capacity, ip_address, port, capabilities, is_healthy)
VALUES ($1, $2, $3, NOW(), $4, $5, $6, $7, $8, TRUE)
ON CONFLICT (id) DO UPDATE
SET last_seen = NOW(), status = EXCLUDED.status, capacity = EXCLUDED.capacity, 
    capabilities = EXCLUDED.capabilities, is_healthy = TRUE
`

type RegisterWorkerParams struct {
	ID           string      `json:"id"`
	Hostname     string      `json:"hostname"`
	Version      string      `json:"version"`
	Status       string      `json:"status"`
	Capacity     []byte      `json:"capacity"`
	IpAddress    *netip.Addr `json:"ip_address"`
	Port         pgtype.Int4 `json:"port"`
	Capabilities []byte      `json:"capabilities"`
}

// ============================================
// WORKERS
// ============================================
func (q *Queries) RegisterWorker(ctx context.Context, arg RegisterWorkerParams) error {
	_, err := q.db.Exec(ctx, registerWorker,
		arg.ID,
		arg.Hostname,
		arg.Version,
		arg.Status,
		arg.Capacity,
		arg.IpAddress,
		arg.Port,
		arg.Capabilities,
	)
	return err
}

const resolveErrorEvent = `-- name: ResolveErrorEvent :exec
UPDATE error_events
SET resolved = TRUE
WHERE id = $1
`

func (q *Queries) ResolveErrorEvent(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, resolveErrorEvent, id)
	return err
}

const setStreamArchiveJob = `-- name: SetStreamArchiveJob :exec
UPDATE streams
SET archive_vod_job_id = $2
WHERE id = $1
`

type SetStreamArchiveJobParams struct {
	ID              pgtype.UUID `json:"id"`
	ArchiveVodJobID pgtype.UUID `json:"archive_vod_job_id"`
}

func (q *Queries) SetStreamArchiveJob(ctx context.Context, arg SetStreamArchiveJobParams) error {
	_, err := q.db.Exec(ctx, setStreamArchiveJob, arg.ID, arg.ArchiveVodJobID)
	return err
}

const updateEncodingProfile = `-- name: UpdateEncodingProfile :exec
UPDATE encoding_profiles
SET name = $2, description = $3, video_codec = $4, audio_codec = $5, 
    width = $6, height = $7, bitrate_kbps = $8, preset = $9, container = $10, 
    config_json = $11, updated_at = NOW()
WHERE id = $1 AND is_system = FALSE
`

type UpdateEncodingProfileParams struct {
	ID          string      `json:"id"`
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	VideoCodec  string      `json:"video_codec"`
	AudioCodec  pgtype.Text `json:"audio_codec"`
	Width       pgtype.Int4 `json:"width"`
	Height      pgtype.Int4 `json:"height"`
	BitrateKbps pgtype.Int4 `json:"bitrate_kbps"`
	Preset      pgtype.Text `json:"preset"`
	Container   pgtype.Text `json:"container"`
	ConfigJson  []byte      `json:"config_json"`
}

func (q *Queries) UpdateEncodingProfile(ctx context.Context, arg UpdateEncodingProfileParams) error {
	_, err := q.db.Exec(ctx, updateEncodingProfile,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.VideoCodec,
		arg.AudioCodec,
		arg.Width,
		arg.Height,
		arg.BitrateKbps,
		arg.Preset,
		arg.Container,
		arg.ConfigJson,
	)
	return err
}

const updateJobCompleted = `-- name: UpdateJobCompleted :exec
UPDATE jobs
SET status = 'completed', finished_at = NOW(), progress_pct = 100, updated_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdateJobCompleted(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, updateJobCompleted, id)
	return err
}

const updateJobFailed = `-- name: UpdateJobFailed :exec
UPDATE jobs
SET status = 'failed', error_message = $2, finished_at = NOW(), updated_at = NOW()
WHERE id = $1
`

type UpdateJobFailedParams struct {
	ID           pgtype.UUID `json:"id"`
	ErrorMessage pgtype.Text `json:"error_message"`
}

func (q *Queries) UpdateJobFailed(ctx context.Context, arg UpdateJobFailedParams) error {
	_, err := q.db.Exec(ctx, updateJobFailed, arg.ID, arg.ErrorMessage)
	return err
}

const updateJobProgress = `-- name: UpdateJobProgress :exec
UPDATE jobs
SET progress_pct = $2, eta_seconds = $3, updated_at = NOW()
WHERE id = $1
`

type UpdateJobProgressParams struct {
	ID          pgtype.UUID `json:"id"`
	ProgressPct pgtype.Int4 `json:"progress_pct"`
	EtaSeconds  pgtype.Int4 `json:"eta_seconds"`
}

func (q *Queries) UpdateJobProgress(ctx context.Context, arg UpdateJobProgressParams) error {
	_, err := q.db.Exec(ctx, updateJobProgress, arg.ID, arg.ProgressPct, arg.EtaSeconds)
	return err
}

const updateJobStarted = `-- name: UpdateJobStarted :exec
UPDATE jobs
SET status = 'processing', started_at = NOW(), assigned_to_worker_id = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateJobStartedParams struct {
	ID                 pgtype.UUID `json:"id"`
	AssignedToWorkerID pgtype.Text `json:"assigned_to_worker_id"`
}

func (q *Queries) UpdateJobStarted(ctx context.Context, arg UpdateJobStartedParams) error {
	_, err := q.db.Exec(ctx, updateJobStarted, arg.ID, arg.AssignedToWorkerID)
	return err
}

const updateJobStatus = `-- name: UpdateJobStatus :exec
UPDATE jobs
SET status = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateJobStatusParams struct {
	ID     pgtype.UUID `json:"id"`
	Status JobStatus   `json:"status"`
}

func (q *Queries) UpdateJobStatus(ctx context.Context, arg UpdateJobStatusParams) error {
	_, err := q.db.Exec(ctx, updateJobStatus, arg.ID, arg.Status)
	return err
}

const updatePluginConfig = `-- name: UpdatePluginConfig :exec
UPDATE plugin_configs
SET config_json = $2, updated_at = NOW()
WHERE id = $1
`

type UpdatePluginConfigParams struct {
	ID         string `json:"id"`
	ConfigJson []byte `json:"config_json"`
}

func (q *Queries) UpdatePluginConfig(ctx context.Context, arg UpdatePluginConfigParams) error {
	_, err := q.db.Exec(ctx, updatePluginConfig, arg.ID, arg.ConfigJson)
	return err
}

const updateRestreamJobStatus = `-- name: UpdateRestreamJobStatus :exec
UPDATE restream_jobs
SET status = $2, current_stats = $3, updated_at = NOW(),
    started_at = CASE WHEN $2 = 'streaming' THEN NOW() ELSE started_at END,
    stopped_at = CASE WHEN $2 = 'stopped' THEN NOW() ELSE stopped_at END
WHERE id = $1
`

type UpdateRestreamJobStatusParams struct {
	ID           pgtype.UUID `json:"id"`
	Status       pgtype.Text `json:"status"`
	CurrentStats []byte      `json:"current_stats"`
}

func (q *Queries) UpdateRestreamJobStatus(ctx context.Context, arg UpdateRestreamJobStatusParams) error {
	_, err := q.db.Exec(ctx, updateRestreamJobStatus, arg.ID, arg.Status, arg.CurrentStats)
	return err
}

const updateStreamLive = `-- name: UpdateStreamLive :exec
UPDATE streams
SET is_live = $2, started_at = CASE WHEN $2 THEN NOW() ELSE started_at END, 
    ended_at = CASE WHEN NOT $2 THEN NOW() ELSE ended_at END
WHERE id = $1
`

type UpdateStreamLiveParams struct {
	ID     pgtype.UUID `json:"id"`
	IsLive bool        `json:"is_live"`
}

func (q *Queries) UpdateStreamLive(ctx context.Context, arg UpdateStreamLiveParams) error {
	_, err := q.db.Exec(ctx, updateStreamLive, arg.ID, arg.IsLive)
	return err
}

const updateStreamMetadata = `-- name: UpdateStreamMetadata :exec
UPDATE streams
SET title = $2, description = $3, thumbnail_url = $4
WHERE id = $1
`

type UpdateStreamMetadataParams struct {
	ID           pgtype.UUID `json:"id"`
	Title        pgtype.Text `json:"title"`
	Description  pgtype.Text `json:"description"`
	ThumbnailUrl pgtype.Text `json:"thumbnail_url"`
}

func (q *Queries) UpdateStreamMetadata(ctx context.Context, arg UpdateStreamMetadataParams) error {
	_, err := q.db.Exec(ctx, updateStreamMetadata,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.ThumbnailUrl,
	)
	return err
}

const updateStreamRestreamDestinations = `-- name: UpdateStreamRestreamDestinations :exec
UPDATE streams
SET restream_destinations = $2
WHERE id = $1
`

type UpdateStreamRestreamDestinationsParams struct {
	ID                   pgtype.UUID `json:"id"`
	RestreamDestinations []byte      `json:"restream_destinations"`
}

func (q *Queries) UpdateStreamRestreamDestinations(ctx context.Context, arg UpdateStreamRestreamDestinationsParams) error {
	_, err := q.db.Exec(ctx, updateStreamRestreamDestinations, arg.ID, arg.RestreamDestinations)
	return err
}

const updateStreamStats = `-- name: UpdateStreamStats :exec
UPDATE streams
SET current_viewers = $2, last_stats = $3
WHERE id = $1
`

type UpdateStreamStatsParams struct {
	ID             pgtype.UUID `json:"id"`
	CurrentViewers pgtype.Int4 `json:"current_viewers"`
	LastStats      []byte      `json:"last_stats"`
}

func (q *Queries) UpdateStreamStats(ctx context.Context, arg UpdateStreamStatsParams) error {
	_, err := q.db.Exec(ctx, updateStreamStats, arg.ID, arg.CurrentViewers, arg.LastStats)
	return err
}

const updateTaskStatus = `-- name: UpdateTaskStatus :exec
UPDATE tasks
SET status = $2, result = $3, updated_at = NOW()
WHERE id = $1
`

type UpdateTaskStatusParams struct {
	ID     pgtype.UUID `json:"id"`
	Status string      `json:"status"`
	Result []byte      `json:"result"`
}

func (q *Queries) UpdateTaskStatus(ctx context.Context, arg UpdateTaskStatusParams) error {
	_, err := q.db.Exec(ctx, updateTaskStatus, arg.ID, arg.Status, arg.Result)
	return err
}

const updateWebhookTriggered = `-- name: UpdateWebhookTriggered :exec
UPDATE webhooks
SET last_triggered_at = NOW(), failure_count = 0, updated_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdateWebhookTriggered(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, updateWebhookTriggered, id)
	return err
}

const updateWorkerHeartbeat = `-- name: UpdateWorkerHeartbeat :exec
UPDATE workers
SET last_seen = NOW(), is_healthy = TRUE
WHERE id = $1
`

func (q *Queries) UpdateWorkerHeartbeat(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, updateWorkerHeartbeat, id)
	return err
}

const updateWorkerStatus = `-- name: UpdateWorkerStatus :exec
UPDATE workers
SET status = $2, is_healthy = $3
WHERE id = $1
`

type UpdateWorkerStatusParams struct {
	ID        string      `json:"id"`
	Status    string      `json:"status"`
	IsHealthy pgtype.Bool `json:"is_healthy"`
}

func (q *Queries) UpdateWorkerStatus(ctx context.Context, arg UpdateWorkerStatusParams) error {
	_, err := q.db.Exec(ctx, updateWorkerStatus, arg.ID, arg.Status, arg.IsHealthy)
	return err
}
