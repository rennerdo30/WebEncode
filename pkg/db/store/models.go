// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package store

import (
	"database/sql/driver"
	"fmt"
	"net/netip"

	"github.com/jackc/pgx/v5/pgtype"
)

type ErrorSeverity string

const (
	ErrorSeverityWarning  ErrorSeverity = "warning"
	ErrorSeverityError    ErrorSeverity = "error"
	ErrorSeverityCritical ErrorSeverity = "critical"
	ErrorSeverityFatal    ErrorSeverity = "fatal"
)

func (e *ErrorSeverity) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ErrorSeverity(s)
	case string:
		*e = ErrorSeverity(s)
	default:
		return fmt.Errorf("unsupported scan type for ErrorSeverity: %T", src)
	}
	return nil
}

type NullErrorSeverity struct {
	ErrorSeverity ErrorSeverity `json:"error_severity"`
	Valid         bool          `json:"valid"` // Valid is true if ErrorSeverity is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullErrorSeverity) Scan(value interface{}) error {
	if value == nil {
		ns.ErrorSeverity, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ErrorSeverity.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullErrorSeverity) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ErrorSeverity), nil
}

type ErrorSource string

const (
	ErrorSourceFrontend ErrorSource = "frontend"
	ErrorSourceKernel   ErrorSource = "kernel"
	ErrorSourceWorker   ErrorSource = "worker"
	ErrorSourcePlugin   ErrorSource = "plugin"
)

func (e *ErrorSource) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ErrorSource(s)
	case string:
		*e = ErrorSource(s)
	default:
		return fmt.Errorf("unsupported scan type for ErrorSource: %T", src)
	}
	return nil
}

type NullErrorSource struct {
	ErrorSource ErrorSource `json:"error_source"`
	Valid       bool        `json:"valid"` // Valid is true if ErrorSource is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullErrorSource) Scan(value interface{}) error {
	if value == nil {
		ns.ErrorSource, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ErrorSource.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullErrorSource) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ErrorSource), nil
}

type JobSourceType string

const (
	JobSourceTypeUrl      JobSourceType = "url"
	JobSourceTypeUpload   JobSourceType = "upload"
	JobSourceTypeStream   JobSourceType = "stream"
	JobSourceTypeRestream JobSourceType = "restream"
)

func (e *JobSourceType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = JobSourceType(s)
	case string:
		*e = JobSourceType(s)
	default:
		return fmt.Errorf("unsupported scan type for JobSourceType: %T", src)
	}
	return nil
}

type NullJobSourceType struct {
	JobSourceType JobSourceType `json:"job_source_type"`
	Valid         bool          `json:"valid"` // Valid is true if JobSourceType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullJobSourceType) Scan(value interface{}) error {
	if value == nil {
		ns.JobSourceType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.JobSourceType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullJobSourceType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.JobSourceType), nil
}

type JobStatus string

const (
	JobStatusQueued     JobStatus = "queued"
	JobStatusProcessing JobStatus = "processing"
	JobStatusCompleted  JobStatus = "completed"
	JobStatusFailed     JobStatus = "failed"
	JobStatusCancelled  JobStatus = "cancelled"
	JobStatusStitching  JobStatus = "stitching"
	JobStatusUploading  JobStatus = "uploading"
)

func (e *JobStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = JobStatus(s)
	case string:
		*e = JobStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for JobStatus: %T", src)
	}
	return nil
}

type NullJobStatus struct {
	JobStatus JobStatus `json:"job_status"`
	Valid     bool      `json:"valid"` // Valid is true if JobStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullJobStatus) Scan(value interface{}) error {
	if value == nil {
		ns.JobStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.JobStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullJobStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.JobStatus), nil
}

type TaskType string

const (
	TaskTypeProbe     TaskType = "probe"
	TaskTypeTranscode TaskType = "transcode"
	TaskTypeStitch    TaskType = "stitch"
	TaskTypeManifest  TaskType = "manifest"
	TaskTypeRestream  TaskType = "restream"
)

func (e *TaskType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TaskType(s)
	case string:
		*e = TaskType(s)
	default:
		return fmt.Errorf("unsupported scan type for TaskType: %T", src)
	}
	return nil
}

type NullTaskType struct {
	TaskType TaskType `json:"task_type"`
	Valid    bool     `json:"valid"` // Valid is true if TaskType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTaskType) Scan(value interface{}) error {
	if value == nil {
		ns.TaskType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TaskType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTaskType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TaskType), nil
}

type AuditLog struct {
	ID           pgtype.UUID        `json:"id"`
	UserID       pgtype.UUID        `json:"user_id"`
	Action       string             `json:"action"`
	ResourceType string             `json:"resource_type"`
	ResourceID   pgtype.Text        `json:"resource_id"`
	Details      []byte             `json:"details"`
	IpAddress    *netip.Addr        `json:"ip_address"`
	UserAgent    pgtype.Text        `json:"user_agent"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
}

type EncodingProfile struct {
	ID          string             `json:"id"`
	Name        string             `json:"name"`
	Description pgtype.Text        `json:"description"`
	VideoCodec  string             `json:"video_codec"`
	AudioCodec  pgtype.Text        `json:"audio_codec"`
	Width       pgtype.Int4        `json:"width"`
	Height      pgtype.Int4        `json:"height"`
	BitrateKbps pgtype.Int4        `json:"bitrate_kbps"`
	Preset      pgtype.Text        `json:"preset"`
	Container   pgtype.Text        `json:"container"`
	IsSystem    pgtype.Bool        `json:"is_system"`
	ConfigJson  []byte             `json:"config_json"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

type ErrorEvent struct {
	ID              pgtype.UUID        `json:"id"`
	SourceComponent string             `json:"source_component"`
	Severity        ErrorSeverity      `json:"severity"`
	Message         string             `json:"message"`
	StackTrace      pgtype.Text        `json:"stack_trace"`
	ContextData     []byte             `json:"context_data"`
	Resolved        pgtype.Bool        `json:"resolved"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
}

type Job struct {
	ID                 pgtype.UUID        `json:"id"`
	SourceUrl          string             `json:"source_url"`
	Profiles           []string           `json:"profiles"`
	Status             JobStatus          `json:"status"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	Metadata           []byte             `json:"metadata"`
	UserID             pgtype.UUID        `json:"user_id"`
	SourceType         NullJobSourceType  `json:"source_type"`
	SourceStreamID     pgtype.UUID        `json:"source_stream_id"`
	ProfileID          pgtype.Text        `json:"profile_id"`
	OutputConfig       []byte             `json:"output_config"`
	ProgressPct        pgtype.Int4        `json:"progress_pct"`
	ErrorMessage       pgtype.Text        `json:"error_message"`
	AssignedToWorkerID pgtype.Text        `json:"assigned_to_worker_id"`
	StartedAt          pgtype.Timestamptz `json:"started_at"`
	FinishedAt         pgtype.Timestamptz `json:"finished_at"`
	EtaSeconds         pgtype.Int4        `json:"eta_seconds"`
}

type JobLog struct {
	ID        pgtype.UUID        `json:"id"`
	JobID     pgtype.UUID        `json:"job_id"`
	Level     string             `json:"level"`
	Message   string             `json:"message"`
	Metadata  []byte             `json:"metadata"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

type Notification struct {
	ID        pgtype.UUID        `json:"id"`
	UserID    pgtype.UUID        `json:"user_id"`
	Title     string             `json:"title"`
	Message   string             `json:"message"`
	Link      pgtype.Text        `json:"link"`
	Type      pgtype.Text        `json:"type"`
	IsRead    pgtype.Bool        `json:"is_read"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
}

type PluginConfig struct {
	ID         string             `json:"id"`
	PluginType string             `json:"plugin_type"`
	ConfigJson []byte             `json:"config_json"`
	IsEnabled  pgtype.Bool        `json:"is_enabled"`
	Priority   pgtype.Int4        `json:"priority"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt  pgtype.Timestamptz `json:"updated_at"`
}

type RestreamJob struct {
	ID                 pgtype.UUID        `json:"id"`
	UserID             pgtype.UUID        `json:"user_id"`
	Title              pgtype.Text        `json:"title"`
	Description        pgtype.Text        `json:"description"`
	InputType          pgtype.Text        `json:"input_type"`
	InputUrl           pgtype.Text        `json:"input_url"`
	OutputDestinations []byte             `json:"output_destinations"`
	ScheduleType       pgtype.Text        `json:"schedule_type"`
	ScheduleConfig     []byte             `json:"schedule_config"`
	LoopEnabled        pgtype.Bool        `json:"loop_enabled"`
	SimulateLive       pgtype.Bool        `json:"simulate_live"`
	Status             pgtype.Text        `json:"status"`
	CurrentStats       []byte             `json:"current_stats"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	StartedAt          pgtype.Timestamptz `json:"started_at"`
	StoppedAt          pgtype.Timestamptz `json:"stopped_at"`
}

type Stream struct {
	ID                   pgtype.UUID        `json:"id"`
	StreamKey            string             `json:"stream_key"`
	IsLive               bool               `json:"is_live"`
	IngestUrl            pgtype.Text        `json:"ingest_url"`
	PlaybackUrl          pgtype.Text        `json:"playback_url"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UserID               pgtype.UUID        `json:"user_id"`
	Title                pgtype.Text        `json:"title"`
	Description          pgtype.Text        `json:"description"`
	ThumbnailUrl         pgtype.Text        `json:"thumbnail_url"`
	IngestServer         pgtype.Text        `json:"ingest_server"`
	CurrentViewers       pgtype.Int4        `json:"current_viewers"`
	TotalViewersLifetime pgtype.Int8        `json:"total_viewers_lifetime"`
	StartedAt            pgtype.Timestamptz `json:"started_at"`
	EndedAt              pgtype.Timestamptz `json:"ended_at"`
	LastStats            []byte             `json:"last_stats"`
	ArchiveEnabled       pgtype.Bool        `json:"archive_enabled"`
	ArchiveVodJobID      pgtype.UUID        `json:"archive_vod_job_id"`
	RestreamDestinations []byte             `json:"restream_destinations"`
}

type Task struct {
	ID              pgtype.UUID        `json:"id"`
	JobID           pgtype.UUID        `json:"job_id"`
	Type            TaskType           `json:"type"`
	Status          string             `json:"status"`
	Params          []byte             `json:"params"`
	WorkerID        pgtype.Text        `json:"worker_id"`
	Result          []byte             `json:"result"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	SequenceIndex   pgtype.Int4        `json:"sequence_index"`
	StartTimeSec    pgtype.Float8      `json:"start_time_sec"`
	EndTimeSec      pgtype.Float8      `json:"end_time_sec"`
	AttemptCount    pgtype.Int4        `json:"attempt_count"`
	MaxAttempts     pgtype.Int4        `json:"max_attempts"`
	OutputKey       pgtype.Text        `json:"output_key"`
	OutputSizeBytes pgtype.Int8        `json:"output_size_bytes"`
}

type Webhook struct {
	ID              pgtype.UUID        `json:"id"`
	UserID          pgtype.UUID        `json:"user_id"`
	Url             string             `json:"url"`
	Secret          string             `json:"secret"`
	Events          []string           `json:"events"`
	IsActive        pgtype.Bool        `json:"is_active"`
	LastTriggeredAt pgtype.Timestamptz `json:"last_triggered_at"`
	FailureCount    pgtype.Int4        `json:"failure_count"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
}

type Worker struct {
	ID           string             `json:"id"`
	Hostname     string             `json:"hostname"`
	Version      string             `json:"version"`
	LastSeen     pgtype.Timestamptz `json:"last_seen"`
	Status       string             `json:"status"`
	Capacity     []byte             `json:"capacity"`
	IpAddress    *netip.Addr        `json:"ip_address"`
	Port         pgtype.Int4        `json:"port"`
	Capabilities []byte             `json:"capabilities"`
	IsHealthy    pgtype.Bool        `json:"is_healthy"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
}
